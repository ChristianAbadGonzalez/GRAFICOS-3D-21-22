<!-- 
    AUTOR: CHRISTIAN ABAD GONZÁLEZ
    ASIGNATURA: GRÁFICOS Y VISUALIZACIÓN EN 3D
    PRÁCTICA FINAL: BREAKOUT

    PARTES IMPLEMENTADAS:
        
        FUNCIONALIDAD BÁSICA:
        
            -
            -
            -
            -
        
        FUNCIONALIDAD AVANAZADA:

            -
            -
            -
            -
        
        MEJORAS:

            -
            -
            -
            -
 -->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/103/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.6/dat.gui.min.js"></script>
    
    <title>PRÁCTICA FINAL -- BREAKOUT</title>
</head>

<body onload="init()"></body>

<script>
    var counter = 0;
    
    function init()  {
        /* Implementación-Creacion de la escena a partir de un Canvas predefinido */
        var scene = new THREE.Scene(),
            sceneWidth = myCanvas.width,
            sceneHeight = myCanvas.heigth,
            ratio = sceneWidth/sceneHeight;
        
        /* var camera = new THREE.PerspectiveCamera(fov, ratio, near, far);
            fov --> Ángulo en grados de la cámara 
            ratio --> Relacion de aspecto (Ancho / Alto)
            near --> Plano de recorte cercano
            far --> Plano de recorte lejano
        */
        var camera = new THREE.PerspectiveCamera(90, ratio, 0.01, 100);
        camera.position.set(0, -10, 15);
        camera.lookAt(scene.position);

        var renderer =  new THREE.WebGLRenderer({
            antialias: true
        });
        
        renderer.shadowMap.enabled = true;
        renderer.setSize(sceneWidth, sceneHeight);
        document.body.appendChild(renderer.domElement);

        var light = getLight(),
            sphere = getSphere(),
            floor = getFloor();

        addLight(scene);
        addSphere(scene);
        addFloor(scene, render);

        animate(sphere, renderer, scene, camera);
    }

    function animate(sphere, renderer, scene, camera) {
        sphere.position.y = 10 * Math.cos(counter);
        sphere.position.z = 1 + 3 * Math.abs(Math.sin(counter))

        renderer.render(scene, camera);
        counter += 0.02;

        requestAnimationFrame(function() {
            animate(sphere, renderer, scene, camera);
        });
    }

    function getLight() {
        var light = new THREE.DirectionalLight();
        
        light.position.set(4, 4, 4);
        light.castShadow = true;
        light.shadow.camera.near = 0;
        light.shadow.camera.far = 16;
        light.shadow.camera.left = -8;
        light.shadow.camera.right = 5;
        light.shadow.camera.top = 10;
        light.shadow.camera.bottom = -10;
        light.shadow.mapSize.width = 4096;
        light.shadow.mapSize.height = 4096;
        
        return light;
    }

    function getSphere() {
        var geometry = new THREE.SphereGeometry(1, 20, 20),
            material = new THREE.MeshNormalMaterial(),
            mesh = new THREE.Mesh(geometry, material);
        
        mesh.position.z = 1;
        mesh.castShadow = true;
        
        return mesh;
    }

    function getFloor() {
        var geometry = new THREE.PlaneGeometry(10, 20),
            texture = new THREE.TextureLoader().load("wood.png");
        
        var material = new THREE.MeshPhysicalMaterial({
            map : texture
        });
        
        material.map.wrapS = material.map.wrapT = THREE.RepeatWrapping;
        material.map.repeat.set(4, 4);
        material.side = THREE.DoubleSide;
      
        var mesh = new THREE.Mesh(geometry, material);
        mesh.receiveShadow = true;
        
        return mesh;
   }

</script>

</html>