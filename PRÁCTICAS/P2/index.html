<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Matrix & Vector Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"></script>
    <title>EJERCICIO EVALUABLE 4</title>
</head>

<body onload="init()">
        <canvas id="myCanvas" width="500" height="500"></canvas>
        <br>
        <b>Step:</b><input type="text" value="0.01" id="step">
</body>

<script id="shaderVs" type="x-shader/x-vertex">
    attribute vec4 a_Position;
    uniform mat4 u_Matrix;
    void main(){
        gl_Position = u_Matrix * a_Position;
    }
</script>

<script id="shaderFs" type="x-shader/x-fragment">
    void main(){
        gl_FragColor = vec4(1.0, 1.0, 0.0, 1.0);
    }
</script>

<script>
    // ------ GLOBAL VARIABLES ------ //
    var drawedMatrix = mat4.create(), // This is the matrix where will we draw
        vertices = new Float32Array([    // vertices
            // DIAMOND Nº1
            -0.40,  0.00,  0.00, // Vertice #0
            -0.50,  0.75,  0.00, // Vertice #1
            -0.60,  0.00,  0.00, // Vertice #2 
            -0.40,  0.00,  0.00, // Vertice #3
            -0.50, -0.75,  0.00, // Vertice #4
            -0.60,  0.00,  0.00, // Vertice #5

            // DIAMOND Nº2
            0.40,   0.00,  0.00, // Vertice #6
            0.50,   0.75,  0.00, // Vertice #7
            0.60,   0.00,  0.00, // Vertice #8
            0.40,   0.00,  0.00, // Vertice #9
            0.50,  -0.75,  0.00, // Vertice #10
            0.60,   0.00,  0.00  // Vertice #11
        ]);  

    // ------ FUNCTION INIT ------ //
    function init(){

        // Create a copy for move the Diamond
        var verticesAux = vertices.slice();

        // Get canvas object from the DOM and Init WebGL Context
        var canvas = document.getElementById("myCanvas");
        gl = canvas.getContext("webgl");

        if (!gl) {
            console.log("FAILED TO GET THE RENDERING CONTEXT FOR WEBGL.");
            return;
        }

        // Init Shaders 
        var vs = document.getElementById('shaderVs').innerHTML,
            fs = document.getElementById('shaderFs').innerHTML;

        if (!initShaders(gl, vs, fs)){
            console.log("FAILED TO INITIALIZE SHADERS.");
            return;
        }

        // Write the position of vertices to a vertices shader
        var n = initVertexBuffers(gl, vertices);

        if (n < 0){
            console.log('FAILED TO SET THE POSITION OF THE VERTICES');
            return;
        }

        // Set Clear Canvas & Color 
        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT);

        // Draw the Starting Matrix
        drawMatrix(gl, drawedMatrix, n);

        document.onkeydown = function (ev) {
            var step = new Number(document.getElementById("step").value), // Get the value of the STEP
                move = [0.0, 0.0, 0.0], // Move vector respect origin
                zoom = [1.0, 1.0, 1.0], // Starting Zoom
                angleZ = 0.0, // Z-Starting Angle
                diamondMove = [0.0, 0.0]; // step of the diamond move

            switch (ev.keyCode) {
                
                case 33: // PageUp
                    zoom = [1 + step, 1 + step, 1 + step];
                    break;
                
                case 34: // PageDown
                    zoom = [1 - step, 1 - step, 1 - step];
                    break;
     
                case 35: // End
                    angleZ = -step;
                    break;
         
                case 36: // Home
                    angleZ = step;
                    break;
            
                case 37: // Left
                    move = [-step, 0, 0];
                    break;
            
                case 38: // Up
                    move = [0, step, 0];
                    break;
                
                case 39: // Right
                    move = [step, 0, 0];
                    break;
                
                case 40: // Down
                    move = [0, -step, 0];
                    break;
                
                case 187: case 107: // 187 --> + [BLOCK NUM];  107 --> + [ENTER]
                    diamondMove = [step, -step];
                    break;
 
                case 189: case 109: // 189 --> - [BLOCK NUM];  109 --> - [ENTER]
                    diamondMove = [-step, step];
                    break;
                
                default:
                    // If you press another key --> ¡ERROR!
                    console.log('¡ERROR!: You are not pressing the correct key.');
                    break;
                }
            
                // Update the drawed matrix
                drawedMatrix = zoomDiamond(drawedMatrix, zoom);     // First zoom
                drawedMatrix = rotateDiamond(drawedMatrix, angleZ); // Second rotate
                drawedMatrix = moveDiamond(drawedMatrix, move);     // Third move
                
                // Update the vertices position
                verticesAux = moveVertices(verticesAux, diamondMove);
                
                // Refrest the Buffer with new displacement the vertices
                gl.bufferData(gl.ARRAY_BUFFER, verticesAux, gl.STATIC_DRAW);

                // Draw the Update Matrix
                drawMatrix(gl, drawedMatrix, n);
            }
        }
    
    // ------ HELPER FUNCTIONS ------ //

    function drawMatrix(gl, matrix, n){
        // gl: webgl context
        // matrix: variable of type mat4 to draw
        // n: number of vertices 
        var u_Matrix = gl.getUniformLocation(gl.program, 'u_Matrix');
        gl.uniformMatrix4fv(u_Matrix, false, matrix);

        // Set Clear Canvas & Color & Draw
        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.drawArrays(gl.TRIANGLES, 0, n);
    }

    function moveVertices(vertices, step) {
        // vertices: Float32Array with the positions of all the vertices
        // step: an array with length 2 with the step of the left and right diamonds
        // returns the position of the vertices after being moved
        var verticesAux = vertices.slice(),
            stepLeft = step[0],
            stepRight = step[1];

        for (var i = 0; i < vertices.length; i = i + 3){
            if (i < vertices.length / 2) {
                verticesAux[i] += stepLeft;
            }else{
                verticesAux[i] += stepRight;
            }
        }
        return verticesAux;
    }

    function rotateDiamond(matrix, angleZ) {
      // matrix: mat4 variable for rotate
      // angle: angle for rotate the matrix
      // returns the matrix after being rotated
      var rotateMatrix = mat4.fromZRotation(mat4.create(), angleZ);

      return mat4.multiply(mat4.create(), matrix, rotateMatrix);
    }

    function zoomDiamond(matrix, zoom) {
      // matrix: mat4 variable for zoom in or out
      // zoom: array with legth 3 with the zoom in axis x, y and z
      // returns the matrix after being zoom in or out
      var zoomMatrix = mat4.fromScaling(mat4.create(), zoom);

      return mat4.multiply(mat4.create(), matrix, zoomMatrix);
    }

    function moveDiamond(matrix, move) {
      // matrix: mat4 variable for move
      // move: array with length 3 with the movement in axis x, y and z
      // returns the matrix after being moved
      var moveMatrix = mat4.fromTranslation(mat4.create(), move);

      return mat4.multiply(mat4.create(), matrix, moveMatrix);
    }
    
    function drawScene(){
        // Set Clear Canvas
        gl.clear(gl.COLOR_BUFFER_BIT);

        // Calculated Position
        var position = Math.sin(0.0);

        // Translation Matrix
        var translation1 = mat4.fromTranslation(mat4.create(), [move[0] + displacement, move[1], 0.0]),
            translation2 = mat4.fromTranslation(mat4.create(), [move[0] - displacement, move[1], 0.0]); 
        
        // Scaled Matrix
        var scaled = mat4.fromScaling(mat4.create(), scale);

        // Rotation Matrix
        var rotation = mat4.fromScaling(mat4.create(), angleZ);

        // Translational Combination
        var matrix1 = mat4.multiply(mat4.create(), translation1, scaled),
            matrix1_rotation = mat4.multiply(mat4.create(), rotation, matrix1),
            matrix2 = mat4.multiply(mat4.create(), translation2, scaled),
            matrix2_rotation = mat4.multiply(mat4.create(), rotation, matrix2);
        
        //Set uniform value (u_Matrix) in verter shader
        var mvMatrixUniform = gl.getUniformLocation(gl.program, "u_Matrix");
        gl.uniformMatrix4fv(mvMatrixUniform, false, matrix1_rotation);

        // Write the position of vertices to a vertex shader
        var n = initVertexBuffers(gl);

        if (n < 0){
            console.log('FAILED TO SET THE POSITION OF THE VERTEX');
        }
        
        //Draw triangles
        gl.drawArrays(gl.TRIANGLES, 0, n); // Draw the vertex 0 to 6

        //Set uniform value (u_Matrix) in verter shader
        var mvMatrixUniform = gl.getUniformLocation(gl.program, "u_Matrix");
        gl.uniformMatrix4fv(mvMatrixUniform, false, matrix2_rotation);
        
        //Draw triangles
        gl.drawArrays(gl.TRIANGLES, 6, n); // Draw the vertex 7 to 12

        //Call drawScene again in the next browser repaint
        requestAnimationFrame(drawScene);       

    }

    function initVertexBuffers(gl, vertices){
 
        // Create a buffer object and Dim the Object
        var dim = 3,
            vertexBuffer = gl.createBuffer();

        if (!vertexBuffer){
            console.log('FAILED TO CREATE THE BUFFER OBJECT');
            return -1;
        }

        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

        // Assing the vertex in  buffer object to a_Position variable
        var a_Position = gl.getAttribLocation(gl.program, 'a_Position');

        if (a_Position < 0){
            console.log('FAILED TO GET THE STORAGE LOCATION OF a_Position');
        }

        gl.vertexAttribPointer(a_Position, dim, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(a_Position);

        // Return number of vertex
        return vertices.length / dim;
    }

    function initShaders(gl, vs_source, fs_source){

        // Create Program & Compile shaders 
        var vertexShader = makeShader(gl, vs_source, gl.VERTEX_SHADER),
            fragmentShader = makeShader(gl, fs_source, gl.FRAGMENT_SHADER),
            glProgram = gl.createProgram();

        // Attach and link shaders to the program 
        gl.attachShader(glProgram, vertexShader);
        gl.attachShader(glProgram, fragmentShader);
        gl.linkProgram(glProgram);

        if (!gl.getProgramParameter(glProgram, gl.LINK_STATUS)){
            alert("UNABLE TO INITIALIZE THE SHADER PROGRAM");
            return false;
        }

        /* Use Program */
        gl.useProgram(glProgram);
        gl.program = glProgram;

        return true;
    }

    function makeShader(gl, src, type){

        var shader = gl.createShader(type);
        gl.shaderSource(shader, src);
        gl.compileShader(shader)

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)){
            alert("ERROR COMPILE SHADER: " + gl.getShaderInfoLog(shader));
            return;
        }
        return shader;
    }
    </script>

</html>