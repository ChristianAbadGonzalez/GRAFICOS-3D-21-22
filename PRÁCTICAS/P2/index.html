<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"></script>
    <title>EJERCICIO EVALUABLE 4</title>
</head>
<body onload="init()">
        <canvas id="myCanvas" width="1000" height="500"></canvas>
</body>
<script id="shaderVs" type="x-shader/x-vertex">
    attribute vec3 a_Position;
    void main(){
        gl_Position = vec4(a_Position, 1.0);
    }
</script>

<script id="shaderFs" type="x-shader/x-fragment">
    void main(){
        gl_FragColor = vec4(1.0, 1.0, 0.0, 1.0);
    }
</script>

<script>
    function init(){

        // Get canvas object from the DOM and Init WebGL Context
        var canvas = document.getElementById("myCanvas"),
            gl = canvas.getContext("webgl");

        if (!gl) {
            console.log("FAILED TO GET THE RENDERING CONTEXT FOR WEBGL.");
            return;
        }
        
        // Init Shaders 
        var vs = document.getElementById('shaderVs').innerHTML,
            fs = document.getElementById('shaderFs').innerHTML;

        if (!initShaders(gl, vs, fs)){
            console.log("FAILED TO INITIALIZE SHADERS.");
            return;
        }

        document.onkeydown = function (ev) {
            var step = new Number(document.getElementById("step").value);
            switch (ev.keyCode) {
                case 37: // Left
                // ...
                break;
                case 39: // Right
                // ...
                break;
                case 38: // Up
                // ...
                break;
                case 40: // Down
                // ...
                break;
                case 33: // PageUp
                // ...
                break;
                case 34: // PageDown
                // ...
                break;
                case 36: // Home
                // ...
                break
                case 35: // End
                // ...
                break;
                case 187: // +
                // ...
                break;
                case 189: // -
                // ...
                break;
                }
                // ...
                };

        // Write the position of vertices to a vertex shader
        var n = initVertexBuffers(gl);

        if (n < 0){
            console.log('FAILED TO SET THE POSITION OF THE VERTICES');
        }

        // Set Clear Canvas & Color 
        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT);

        // Draw
        gl.drawArrays(gl.TRIANGLES, 0, n);
    }

    function initVertexBuffers(gl){

        // Vertices
        var dim = 3,
            vertices = new Float32Array([
                // ROMBO Nº1
                -0.4, 0, 0, // Vertice #1
                -0.5, 0.75, 0, // Vertice #2
                -0.6, 0, 0, // Vertice #3 
                -0.4, 0, 0, // Vertice #4
                -0.5, -0.75, 0, // Vertice #5
                -0.6, 0, 0, // Vertice #6

                // ROMBO Nº2
                0.4, 0, 0, // Vertice #1
                0.5, 0.75, 0, // Vertice #2
                0.6, 0, 0, // Vertice #3
                0.4, 0, 0, // Vertice #4
                0.5, -0.75, 0, // Vertice #5
                0.6, 0, 0 // Vertice #6
            ])
        
        // Create a buffer object
        var vertexBuffer = gl.createBuffer();

        if (!vertexBuffer){
            console.log('FAILED TO CREATE THE BUFFER OBJECT');
            return -1;
        }

        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

        // Assing the vertices in  buffer object to a_Position variable
        var a_Position = gl.getAttribLocation(gl.program, 'a_Position');

        if (a_Position < 0){
            console.log('FAILED TO GET THE STORAGE LOCATION OF a_Position');
        }

        gl.vertexAttribPointer(a_Position, dim, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(a_Position);

        // Return number of vertices
        return vertices.length / dim;
    }

    function initShaders(gl, vs_source, fs_source){

        // Compile shaders 
        var vertexShader = makeShader(gl, vs_source, gl.VERTEX_SHADER);
        var fragmentShader = makeShader(gl, fs_source, gl.FRAGMENT_SHADER);

        // Create Program
        var glProgram = gl.createProgram();

        // Attach and link shaders to the program 
        gl.attachShader(glProgram, vertexShader);
        gl.attachShader(glProgram, fragmentShader);
        gl.linkProgram(glProgram);

        if (!gl.getProgramParameter(glProgram, gl.LINK_STATUS)){
            alert("UNABLE TO INITIALIZE THE SHADER PROGRAM");
            return false;
        }

        /* Use Program */
        gl.useProgram(glProgram);
        gl.program = glProgram;

        return true;
    }

    function makeShader(gl, src, type){

        var shader = gl.createShader(type);
        gl.shaderSource(shader, src);
        gl.compileShader(shader)

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)){
            alert("ERROR COMPILE SHADER: " + gl.getShaderInfoLog(shader));
            return;
        }
        return shader;
    }
</script>
</html>