<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Matrix & Vector Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"></script>
    <title>EJERCICIO EVALUABLE 4</title>
</head>

<body onload="init()">
    <canvas id="myCanvas" width="640" height="480"></canvas>
    <br>
    <b>Step:</b><input type="text" value="0.01" id="step">
</body>

<script id="shaderVs" type="x-shader/x-vertex">
    attribute vec4 a_Position;
    uniform mat4 u_Matrix;
    attribute vec4 a_Color;
    varying highp vec4 v_Color;
    void main(){
        gl_Position = u_Matrix * a_Position;
        v_Color = a_Color;
    }
</script>

<script id="shaderFs" type="x-shader/x-fragment">
    varying highp vec4 v_Color;
    void main(){
        gl_FragColor = v_Color;
    }
</script>

<script>

    var gl,
        count = 0.0,
        x = 0.0,
        y = 0.0,
        scale = 1.0,
        desp = 0.0,
        start = false;

    // ------ FUNCTION INIT ------ //
    function init(){

        // Get canvas object from the DOM and Init WebGL Context
        var canvas = document.getElementById("myCanvas");
        gl = canvas.getContext("webgl");

        if (!gl) {
            console.log("FAILED TO GET THE RENDERING CONTEXT FOR WEBGL.");
            return;
        }

        // Init Shaders 
        var vs = document.getElementById('shaderVs').innerHTML,
            fs = document.getElementById('shaderFs').innerHTML;

        if (!initShaders(gl, vs, fs)){
            console.log("FAILED TO INITIALIZE SHADERS.");
            return;
        }
        
        buttonControls();

        // Write the position of vertices to a vertices shader
        var n = initVertexBuffers(gl);

        if (n < 0){
            console.log('FAILED TO SET THE POSITION OF THE VERTICES');
            return;
        }

        // Clear canvas
        gl.clearColor(0.0, 0.0, 0.0, 1.0); //negro
        gl.clear(gl.COLOR_BUFFER_BIT);

        // Draw the triangles arrays
        gl.drawArrays(gl.TRIANGLES, 0, n);

        // Draw scene
        drawScene();
    }

    function buttonControls(){
        document.onkeydown = function (ev) {
        var step = new Number(document.getElementById("step").value); // Get the value of the STEP

        switch (ev.keyCode) {

            case 32: //space
                start = true;
                count = 0.0;
                x = 0.0;
                y = 0.0;
                drawScene()                 
            break;

            case 33: // PageUp
                scale += step
            break;
            
            case 34: // PageDown
                scale -= step;
            break;
    
            case 35: // End
                count += step;
            break;
        
            case 36: // Home
                count -= step 
            break;
        
            case 37: // Left
                x -= step;
            break;
        
            case 38: // Up
                y -= step;
            break;
            
            case 39: // Right
                x += step;
            break;
            
            case 40: // Down
                y += step;
            break;

            case 77: //multicolor degradado
                drawSceneDNew();
            break;

            case 82: // color red
                drawSceneNew();
            break;
            
            case 187: case 107: // 187 --> + [BLOCK NUM];  107 --> + [ENTER]
                desp -= desp + step;
            break;

            case 189: case 109: // 189 --> - [BLOCK NUM];  109 --> - [ENTER]
                desp += desp - step;
            break;
            
            default:
                // If you press another key --> ¡ERROR!
                console.log('¡ERROR!: You are not pressing the correct key.');
                break;
        }
        drawScene();
    }
    }

    // ------ DRAW FUNCTIONS ------ //

    function drawScene(){
        // Set Clear Color & Canvas
        gl.clear(gl.COLOR_BUFFER_BIT);

        //matriz para calcular la traslacion
        var traslation = mat4.fromTranslation(mat4.create(), [x + desp, y, 0.0]),
            traslation1 = mat4.fromTranslation(mat4.create(), [x - desp, y, 0.0]);

        //matriz para calcular el escalado
        var scaled = mat4.fromScaling(mat4.create(), [scale,scale,0.0]);

        //matriz para calcular la rotacion
        var rotation = mat4.fromZRotation(mat4.create(), count);
            
        //matrices generales
        var matrix1 = matrix = mat4.multiply(mat4 .create(), traslation, scaled),
            matrix2 = mat4.multiply(mat4 .create(), traslation1, scaled);

        // matrices finales
        var matrix_final1 = mat4.multiply(mat4 .create(), rotation, matrix1), 
            matrix_final2 = mat4.multiply(mat4 .create(), rotation, matrix2);
        
        // Write the position of vertices to a vertices shader
        var n = initVertexBuffers(gl);

        if (n < 0){
            console.log('FAILED TO SET THE POSITION OF THE VERTICES');
            return;
        }

        //Set uniform value (u_Matrix) in verter shader
        var mvMatrixUniform = gl.getUniformLocation(gl.program, "u_Matrix");
        gl.uniformMatrix4fv(mvMatrixUniform, false, matrix_final1);
        gl.drawArrays(gl.TRIANGLES, 0, 6);

        //Set uniform value (u_Matrix) in verter shader
        var mvMatrixUniform = gl.getUniformLocation(gl.program, "u_Matrix");
        gl.uniformMatrix4fv(mvMatrixUniform, false, matrix_final2);
        gl.drawArrays(gl.TRIANGLES, 6, n);

        //Call drawScene again in the next browser repaint
        requestAnimationFrame(drawScene);   
    };

    function drawSceneNew(){
        // Set Clear Color & Canvas
        gl.clear(gl.COLOR_BUFFER_BIT);

        //matriz para calcular la traslacion
        var traslation = mat4.fromTranslation(mat4.create(), [x + desp, y, 0.0]),
            traslation1 = mat4.fromTranslation(mat4.create(), [x - desp, y, 0.0]);

        //matriz para calcular el escalado
        var scaled = mat4.fromScaling(mat4.create(), [scale,scale,0.0]);

        //matriz para calcular la rotacion
        var rotation = mat4.fromZRotation(mat4.create(), count);
            
        //matrices generales
        var matrix1 = matrix = mat4.multiply(mat4 .create(), traslation, scaled),
            matrix2 = mat4.multiply(mat4 .create(), traslation1, scaled);

        // matrices finales
        var matrix_final1 = mat4.multiply(mat4 .create(), rotation, matrix1), 
            matrix_final2 = mat4.multiply(mat4 .create(), rotation, matrix2);

        // Write the position of vertices to a vertices shader
        var n = initVertexBuffers(gl);

        if (n < 0){
            console.log('FAILED TO SET THE POSITION OF THE VERTICES');
            return;
        }

        //Set uniform value (u_Matrix) in verter shader
        var mvMatrixUniform = gl.getUniformLocation(gl.program, "u_Matrix");
        gl.uniformMatrix4fv(mvMatrixUniform, false, matrix_final1);
        gl.drawArrays(gl.TRIANGLES, 0, 6);

        //Set uniform value (u_Matrix) in verter shader
        var mvMatrixUniform = gl.getUniformLocation(gl.program, "u_Matrix");
        gl.uniformMatrix4fv(mvMatrixUniform, false, matrix_final2);
        gl.drawArrays(gl.TRIANGLES, 6, n);

        //Call drawScene again in the next browser repaint
        requestAnimationFrame(drawSceneNew);
    }

    function drawSceneDNew(){
        // Set Clear Color & Canvas
        gl.clear(gl.COLOR_BUFFER_BIT);

        //matriz para calcular la traslacion
        var traslation = mat4.fromTranslation(mat4.create(), [x + desp, y, 0.0]),
            traslation1 = mat4.fromTranslation(mat4.create(), [x - desp, y, 0.0]);

        //matriz para calcular el escalado
        var scaled = mat4.fromScaling(mat4.create(), [scale,scale,0.0]);

        //matriz para calcular la rotacion
        var rotation = mat4.fromZRotation(mat4.create(), count);
            
        //matrices generales
        var matrix1 = matrix = mat4.multiply(mat4 .create(), traslation, scaled),
            matrix2 = mat4.multiply(mat4 .create(), traslation1, scaled);

        // matrices finales
        var matrix_final1 = mat4.multiply(mat4 .create(), rotation, matrix1), 
            matrix_final2 = mat4.multiply(mat4 .create(), rotation, matrix2);

        // Write the position of vertices to a vertices shader
        var n = initVertexBuffers(gl);

        if (n < 0){
            console.log('FAILED TO SET THE POSITION OF THE VERTICES');
            return;
        }

        //Set uniform value (u_Matrix) in verter shader
        var mvMatrixUniform = gl.getUniformLocation(gl.program, "u_Matrix");
        gl.uniformMatrix4fv(mvMatrixUniform, false, matrix_final1);
        gl.drawArrays(gl.TRIANGLES, 0, 6);

        //Set uniform value (u_Matrix) in verter shader
        var mvMatrixUniform = gl.getUniformLocation(gl.program, "u_Matrix");
        gl.uniformMatrix4fv(mvMatrixUniform, false, matrix_final2);
        gl.drawArrays(gl.TRIANGLES, 6, n);

        //Call drawScene again in the next browser repaint
        requestAnimationFrame(drawSceneDNew);
    }

    function initVertexBuffers(gl){
        var dim = 3;
        var vertices = [
            // rectangulo izquierdo
            -0.6, -0.4, 0.0,  -0.15, 0.4, 0.0,  -0.15, -0.4,0.0, // Triangulo 1
            -0.15, 0.4,0.0,   -0.6, -0.4,0.0,   -0.6, 0.4,0.0,  // Triangulo 2

            0.15, -0.4,0.0,   0.15, 0.4,0.0,    0.6, 0.4,0.0,  // Triangulo 3
            0.6, -0.4,0.0,    0.15, -0.4,0.0,   0.6, 0.4,0.0,   // Triangulo 4

        ];


        var colorInicio = [
            0.5647, 0.9333, 0.5647,   0.5647, 0.9333, 0.5647,   0.5647, 0.9333, 0.5647, //Triangulo 1                         
            0.5647, 0.9333, 0.5647,   0.5647, 0.9333, 0.5647,   0.5647, 0.9333, 0.5647, //Triangulo 2

            0.5647, 0.9333, 0.5647,   0.5647, 0.9333, 0.5647,   0.5647, 0.9333, 0.5647, //Triangulo 3                         
            0.5647, 0.9333, 0.5647,   0.5647, 0.9333, 0.5647,   0.5647, 0.9333, 0.5647, //Triangulo 4

        ];

        // Create a buffer object and Dim the Object
        var vertexBuffer = gl.createBuffer();

        if (!vertexBuffer){
            console.log('FAILED TO CREATE THE BUFFER OBJECT');
            return -1;
        }

        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

        // Assing the vertex in  buffer object to a_Position variable
        var a_Position = gl.getAttribLocation(gl.program, 'a_Position');

        if (a_Position < 0){
            console.log('FAILED TO GET THE STORAGE LOCATION OF a_Position');
        }

        gl.vertexAttribPointer(a_Position, dim, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(a_Position);
        
        // Create buffer object with the color.
        var ColorBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, ColorBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, colorInicio, gl.STATIC_DRAW);
        
        var a_Color = gl.getUniformLocation(gl.program, 'a_Color');
        gl.vertexAttribPointer(a_Color, dim, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(a_Color);

        // Return number of vertex
        return vertices.length / dim;
    }

    function initVertexBuffers2(gl) {
        var dim = 3;

        // Triangle
        var vertices = [
            // rectangulo izquierdo
            -0.6, -0.4, 0.0,   -0.15, 0.4, 0.0,   -0.15, -0.4,0.0, // Triangulo 1
            -0.15, 0.4,0.0,  -0.6, -0.4,0.0,   -0.6, 0.4,0.0,  // Triangulo 2

            0.15, -0.4,0.0,   0.15, 0.4,0.0,   0.6, 0.4,0.0,  // Triangulo 3
            0.6, -0.4,0.0,    0.15, -0.4,0.0,   0.6, 0.4,0.0,   // Triangulo 4

        ];


        var color_rojo = [
            1.0, 0.0, 0.0,  1.0, 0.0, 0.0,  1.0, 0.0, 0.0, //Triangulo 1                         
            1.0, 0.0, 0.0,  1.0, 0.0, 0.0,  1.0, 0.0, 0.0, //Triangulo 2

            1.0, 0.0, 0.0,  1.0, 0.0, 0.0,  1.0, 0.0, 0.0, //Triangulo 3                         
            1.0, 0.0, 0.0,  1.0, 0.0, 0.0,  1.0, 0.0, 0.0, //Triangulo 4

        ];

        // Create a buffer object
        gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

        // Assign the vertices in buffer object to a_Position variable
        var a_Position = gl.getAttribLocation(gl.program, 'a_Position');
        gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(a_Position);

        // Create buffer object with the color.
        var ColorBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, ColorBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, color_rojo, gl.STATIC_DRAW);
        
        var a_Color = gl.getUniformLocation(gl.program, 'a_Color');
        gl.vertexAttribPointer(a_Color, dim, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(a_Color);

        return vertices.length / dim;
    }

    function initVertexBuffers3(gl) {
        var dim = 3;

        // Triangle
        var vertices = [
            // rectangulo izquierdo
            -0.6, -0.4, 0.0,   -0.15, 0.4, 0.0,   -0.15, -0.4,0.0, // Triangulo 1
            -0.15, 0.4,0.0,  -0.6, -0.4,0.0,   -0.6, 0.4,0.0,  // Triangulo 2

            0.15, -0.4,0.0,   0.15, 0.4,0.0,   0.6, 0.4,0.0,  // Triangulo 3
            0.6, -0.4,0.0,    0.15, -0.4,0.0,   0.6, 0.4,0.0,   // Triangulo 4
        ];


        var colors = [
            0.0, 0.0, 1.0,  0.0, 1.0, 0.0,  1.0, 1.0, 0.0, //Triangulo 1                         
            0.0, 1.0, 0.0,  0.0, 0.0, 1.0,  1.0, 0.0, 0.0, //Triangulo 2

            0.0, 0.0, 1.0,  1.0, 0.0, 0.0,  0.0, 1.0, 0.0, //Triangulo 3                         
            1.0, 1.0, 0.0,  0.0, 0.0, 1.0,  0.0, 1.0, 0.0, //Triangulo 
        ];

        // Create a buffer object
        gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

        // Assign the vertices in buffer object to a_Position variable
        var a_Position = gl.getAttribLocation(gl.program, 'a_Position');
        gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(a_Position);

        // Create buffer object with the color.
        var ColorBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, ColorBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);
        
        var a_Color = gl.getUniformLocation(gl.program, 'a_Color');
        gl.vertexAttribPointer(a_Color, dim, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(a_Color);

        return vertices.length / dim;
    }


    function initShaders(gl, vs_source, fs_source){

        // Create Program & Compile shaders 
        var vertexShader = makeShader(gl, vs_source, gl.VERTEX_SHADER),
            fragmentShader = makeShader(gl, fs_source, gl.FRAGMENT_SHADER),
            glProgram = gl.createProgram();

        // Attach and link shaders to the program 
        gl.attachShader(glProgram, vertexShader);
        gl.attachShader(glProgram, fragmentShader);
        gl.linkProgram(glProgram);

        if (!gl.getProgramParameter(glProgram, gl.LINK_STATUS)){
            alert("UNABLE TO INITIALIZE THE SHADER PROGRAM");
            return false;
        }

        /* Use Program */
        gl.useProgram(glProgram);
        gl.program = glProgram;

        return true;
    }

    function makeShader(gl, src, type){

        var shader = gl.createShader(type);
        gl.shaderSource(shader, src);
        gl.compileShader(shader)

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)){
            alert("ERROR COMPILE SHADER: " + gl.getShaderInfoLog(shader));
            return;
        }
        return shader;
    }
</script>

</html>